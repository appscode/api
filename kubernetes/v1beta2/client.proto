syntax = "proto3";

package appscode.kubernetes.v1beta2;

option go_package = "v1beta2";

option java_multiple_files = true;
option java_outer_classname = "ClientProto";
option java_package = "com.appscode.api.kubernetes.v1beta2";

import "google/api/annotations.proto";
import "appscode/api/annotations.proto";
import "appscode/api/dtypes/types.proto";

service Clients {
  rpc List(ListResourceRequest) returns (ListResourceResponse){
    option (google.api.http) = {
      get : "/_appscode/api/kubernetes/v1beta2/clusters/{cluster}/{type}"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Describe(DescribeResourceRequest) returns (DescribeResourceResponse){
    option (google.api.http) = {
      get : "/_appscode/api/kubernetes/v1beta2/clusters/{cluster}/{type}/{name}"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Create(CreateResourceRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      post: "/_appscode/api/kubernetes/v1beta2/clusters/{cluster}/{type}"
      body : "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Delete(DeleteResourceRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      delete: "/_appscode/api/kubernetes/v1beta2/clusters/{cluster}/{type}/{name}"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Update(UpdateResourceRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      put : "/_appscode/api/kubernetes/v1beta2/clusters/{cluster}/{type}/{name}"
      body : "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Copy(CopyResourceRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      put : "/_appscode/api/kubernetes/v1beta2/actions/copy"
      body : "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  // Followings are type specific actions api, that can be applied upon fixed resources.
  // TODO: (@sadlil) Consider seperating them.
  rpc EditConfigMap(ConfigMapEditRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      post : "/_appscode/api/kubernetes/v1beta2/clusters/{cluster}/namespaces/{namespace}/configmaps/{name}/actions/edit"
      body : "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc EditSecret(SecretEditRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      post : "/_appscode/api/kubernetes/v1beta2/clusters/{cluster}/namespaces/{namespace}/secrets/{name}/actions/edit"
      body : "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc RegisterPersistentVolume(PersistentVolumeRegisterRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      post: "/_appscode/api/kubernetes/v1beta2/clusters/{cluster}/persistentvolumes/{name}/actions/register"
      body: "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc UnregisterPersistentVolume(PersistentVolumeUnRegisterRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      delete: "/_appscode/api/kubernetes/v1beta2/clusters/{cluster}/persistentvolumes/{name}/actions/unregister"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc RegisterPersistentVolumeClaim(PersistentVolumeClaimRegisterRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      post: "/_appscode/api/kubernetes/v1beta2/clusters/{cluster}/persistentvolumeclaims/{name}/actions/register"
      body: "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc UnregisterPersistentVolumeClaim(PersistentVolumeClaimUnRegisterRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      delete: "/_appscode/api/kubernetes/v1beta2/clusters/{cluster}/persistentvolumeclaims/{name}/actions/unregister"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }
}

message ListResourceRequest {
  string cluster = 1;
  string type = 2;
  string namespace = 3;
  bool include_metrics = 4;
  Ancestor ancestor = 5;
  map<string, string> label_selector = 6;

  message Ancestor {
      string type = 1;
      string name = 2;
  }
}

message ListResourceResponse {
  dtypes.Status status = 1;
  KubeResourceList resources = 2;
}

message DescribeResourceRequest {
  string cluster = 1;
  string type = 2;
  string namespace = 3;
  string name = 4;
  string raw = 5;
  bool include_metrics = 6;
}

message DescribeResourceResponse {
  dtypes.Status status = 1;
  KubeResource resource = 2;
}

message UpdateResourceRequest {
  string cluster = 1;
  string type = 2;
  string namespace = 3;
  string name = 4;
  Raw raw = 5;
}

message ConfigMapEditRequest {
  string cluster = 1;
  string namespace = 2;
  string name = 3;
  map<string, string> add = 4;
  map<string, string> update = 5;
  repeated string deleted = 6;
}

message SecretEditRequest {
  string cluster = 1;
  string namespace = 2;
  string name = 3;
  map<string, string>  add = 4;
  map<string, string>  update = 5;
  repeated string deleted = 6;
}

message CopyResourceRequest {
  KubeObject source = 1;
  KubeObject destination = 2;
}

message CreateResourceRequest {
  string cluster = 1;
  string type = 2;
  string name = 4;
  Raw raw = 5;
}

message DeleteResourceRequest {
  string cluster = 1;
  string type = 2;
  string namespace = 3;
  string name = 4;
}

message KubeResourceList {
  string type = 1;
  oneof  resource {
    Apps apps = 2;
    ConfigMaps config_maps = 3;
    DaemonSets daemon_sets = 4;
    Deployments deployments = 5;
    Jobs jobs = 6;
    Namespaces namespaces = 7;
    Nodes nodes = 8;
    StatefulSets stateful_sets = 9;
    Pods pods = 10;
    ReplicaSets replica_sets = 11;
    Services services = 12;
    Secrets secrets = 13;
    ReplicationControllers replication_controllers = 14;
    StorageClasses storage_classes = 15;
    PersistentVolumes persistent_volumes = 16;
    PersistentVolumeClaims persistent_volume_claims = 17;
    Alerts alerts = 18;
    Roles roles = 19;
    ClusterRoles cluster_roles = 20;
    RoleBindings role_bindings = 21;
    ClusterRoleBindings cluster_role_bindings = 22;
    Certificates certificates = 23;
    CronJobs cron_jobs = 24;
  }

  message Apps {
    repeated App items = 1;
  }

  message ConfigMaps {
    repeated ConfigMap items = 1;
  }

  message DaemonSets {
    repeated DaemonSet items = 1;
  }

  message Deployments {
    repeated Deployment items = 1;
  }

  message Jobs {
    repeated Job items = 1;
  }

  message Namespaces {
    repeated Namespace items = 1;
  }

  message Nodes {
    repeated Node items = 1;
  }

  message StatefulSets {
    repeated StatefulSet items = 1;
  }

  message Pods {
    repeated Pod items = 1;
  }

  message ReplicaSets {
    repeated ReplicaSet items = 1;
  }

  message Services {
    repeated Service items = 1;
  }

  message Secrets {
    repeated Secret items = 1;
  }

  message ReplicationControllers {
    repeated ReplicationController items = 1;
  }

  message StorageClasses {
      repeated StorageClass items = 1;
  }

  message PersistentVolumes {
    repeated PersistentVolume items = 1;
  }

  message PersistentVolumeClaims {
    repeated PersistentVolumeClaim items = 1;
  }

  message Alerts {
    repeated Alert items = 1;
  }

  message Roles {
    repeated Role items = 1;
  }

  message ClusterRoles {
    repeated ClusterRole items = 1;
  }

  message RoleBindings {
    repeated RoleBinding items = 1;
  }

  message ClusterRoleBindings {
    repeated ClusterRoleBinding items = 1;
  }

  message Certificates {
    repeated Certificate items = 1;
  }

  message CronJobs {
      repeated CronJob items = 1;
  }
}

// TODO: (@sadlil): when kubernetes moves to protobuf completely import fileds from there.
message KubeResource {
  string type = 1;
  oneof  resource {
    App app = 2;
    ConfigMap config_map = 3;
    DaemonSet daemon_set = 4;
    Deployment deployment = 5;
    Job job = 6;
    Namespace namespace = 7;
    Node node = 8;
    StatefulSet stateful_set = 9;
    Pod pod = 10;
    ReplicaSet replica_set = 11;
    Service service = 12;
    Secret secret = 13;
    ReplicationController replication_controller = 14;
    StorageClass storage_class = 15;
    PersistentVolume persistent_volume = 16;
    PersistentVolumeClaim persistent_volume_claim = 17;
    Alert alert = 20;
    Role role = 21;
    ClusterRole cluster_role = 22;
    RoleBinding role_binding = 23;
    ClusterRoleBinding cluster_role_binding = 24;
    Certificate certificate = 25;
    CronJob cron_job = 26;
  }
  repeated Event events = 18;
  Raw raw = 19;
}

message Meta {
  string name = 1;
  string namespace = 2;
  string self_links = 3;
  string resource_version = 4;
  int64 created_at = 5;
  int64 generation = 6;
  map<string, string> labels = 7;
  map<string, string> annotations = 8;
}

message KubeObject {
  string cluster = 1;
  string type = 2;
  string namespace = 3;
  string name = 4;
}

message IcingaState {
    int32 OK = 1;
    int32 Warning = 2;
    int32 Critical = 3;
    int32 Unknown = 4;
}

message App {
  string cluster = 1;
  string type = 2;
  string namespace = 3;
  string name = 4;
  Service app = 5;
  map<string, string> links = 6;
  int64 created_at = 7;
  string cluster_ip = 8;
  IcingaState icinga_state = 9;
}

message PodSpec {
  repeated  Volume  volumes = 1;
  repeated  Container containers = 2;
  map<string, string> node_selectors = 3;
  string service_account_name = 4;
  string node_name = 5;
  repeated string image_pull_secrets = 6;

  message Container {
    string name  = 1;
    string image = 2;
    repeated string commands = 3;
    repeated VolumeMount volume_mounts = 4;

    message VolumeMount {
      string name = 1;
      bool read_only = 2;
      string mount_path = 3;
    }
  }

  message Volume {
    string name = 1;
    string host_path = 2;
  }
}

message Raw {
  string format = 1;
  string data = 2;
}

message ConfigMap {
  Meta meta = 1;
  map<string, string> data = 2;
}

message Job {
  Meta meta = 1;
  string app = 2;
  JobSpec space = 3;
  Status status = 4;

  message Status {
    int64 start_time = 1;
    int64 completion_time = 2;
    int32 active = 3;
    int32 succeeded = 4;
    int32 failed = 5;
  }
}

message JobSpec {
    int32 parallelism = 1;
    int32 completions = 2;
    PodSpec template = 3;
}

message Namespace {
  Meta meta = 1;
  Status status = 2;

  message Status {
    string phase = 1;
  }
}

message Node {
  Meta meta = 1;
  Spec spec = 2;
  bool is_master = 3;
  Status status = 4;
  Metrics metrics = 5;

  message Spec {
    string external_id = 1;
    string provider_id = 2;
    bool unschedulable = 3;
  }

  message Status {
    Capacity capacity = 1;
    string phase = 2;
    NodeInfo node_info = 3;

    message Capacity {
      int64 cpu = 1;
      int64 memory = 2;
      int64 pods = 3;
    }

    message NodeInfo {
      string kernel_version = 1;
      string os_image = 2;
      string container_runtime_version = 3;
      string kubelet_version = 4;
      string kube_proxy_version = 5;
    }
  }
}

message Pod {
  Meta meta = 1;
  string app = 2;
  PodSpec spec = 3;
  Status status = 4;
  Metrics metrics = 5;

  message Status {
    string phase = 1;
    string message = 2;
    string reason = 3;
    string hostIP = 4;
    string podIP = 5;
  }
}

message PersistentVolume {
  Meta meta = 1;
  PersistentVolumeSpec spec = 2;
  PersistentVolumeStatus status = 3;

  message PersistentVolumeSpec {
    map <string, string> capacity = 1;
    repeated string access_modes = 2;
    string persistent_volume_reclaim_policy = 3;
    ObjectReference claim_ref = 4;
    PersistentVolumeSource persistent_volume_source = 5;
  }

  message PersistentVolumeStatus {
    string phase = 1;
    string message = 2;
    string reason = 3;
  }
}

message PersistentVolumeClaim {
  Meta meta = 1;
  PersistentVolumeClaimSpec spec = 2;
  PersistentVolumeClaimStatus status = 3;

  message PersistentVolumeClaimSpec {
    repeated string access_modes = 1;
    ResourceRequirements resources = 2;
    string volume_name = 3;

    message ResourceRequirements {
        map<string, string> limits = 1;
        map<string, string> requests = 2;
    }
  }

  message PersistentVolumeClaimStatus {
    string phase = 1;
    repeated string access_modes = 2;
    map <string, string> capacity = 3;
  }
}

message ObjectReference {
  string kind = 1;
  string namespace = 2;
  string name = 3;
  string uid = 4;
  string API_version = 5;
  string resource_version = 6;
}

message Service {
  Meta meta = 1;
  string app = 2;
  Spec spec = 3;
  Status status = 4;

  message Spec {
    string type = 1;
    repeated Port ports = 2;
    map<string, string> seletors = 3;
    string clusterIP = 4;
    repeated string externalIPs = 5;
    string loadbalancerIP = 6;

    message Port {
      string name = 1;
      string protocol = 2;
      int32 port = 3;
      string target_port = 4;
      int32 node_port = 5;
    }
  }

  message Status {
    repeated LoadBalancerIngress loadbalancer_ingresses = 1;

    message LoadBalancerIngress {
      string host_name = 1;
      string IP = 2;
    }
  }
}

message Secret {
  Meta meta = 1;
  map<string, string> data = 2;
  string type = 3;
}

message ReplicationController {
  Meta meta = 1;
  string app = 2;
  Spec spec = 3;
  Status status = 4;

  message Spec {
    int32 desired_replicas = 1;
    map<string, string> selectors = 2;
    PodSpec pod_template = 3;
  }

  message Status {
    int32 current_replicas = 1;
    int64 observed_generation = 2;
  }
}

message ReplicaSet {
  Meta meta = 1;
  string app = 2;
  Spec spec = 3;
  Status status = 4;

  message Spec {
    int32 desired_replicas = 1;
    LabelSelector selector = 2;
    PodSpec pod_template = 3;
  }

  message Status {
    int32 current_replicas = 1;
    int64 observed_generation = 2;
  }
}

message DaemonSet {
  Meta meta = 1;
  string app = 2;
  Spec spec = 3;
  Status status = 4;

  message Spec {
    LabelSelector selector = 1;
    PodSpec pod_template = 2;
  }

  message Status {
    int32 current_number_scheduled = 1;
    int32 number_misscheduled = 2;
    int32 desired_number_scheduled = 3;
  }
}

message Deployment {
  Meta meta = 1;
  string app = 2;
  Spec spec = 3;
  Status status = 4;

  message Spec {
    int32 desired_replicas = 1;
    LabelSelector selector = 2;
    PodSpec pod_template = 3;
  }

  message Status {
    int64 observed_generation = 1;
    int32 replicas = 2;
    int32 updated_replicas = 3;
    int32 available_replicas = 4;
    int32 unavailable_replicas = 5;
  }
}

message StatefulSet {
  Meta meta = 1;
  string app = 2;
  Spec spec = 3;
  Status status = 4;

  message Spec {
    int32 desired_replicas = 1;
    LabelSelector selector = 2;
    PodSpec pod_template = 3;
    string service_name = 4;
  }

  message Status {
    int32 current_replicas = 1;
    int64 observed_generation = 2;
  }
}

message StorageClass {
    Meta meta = 1;
    string provisioner = 2;
    map<string, string> parameters = 3;
}

message LabelSelector {
  map<string, string> match_labels = 1;
}

message Event {
  Meta meta = 1;
  string reason = 2;
  string message = 3;
  EventSource source = 4;
  int64 first_timestamp = 5;
  int64 last_timestamp = 6;
  int32 count = 7;
  string type = 8;
}

message EventSource {
  string componenet = 1;
  string host = 2;
}

message Metrics {
  repeated DataPoint cpu_usage = 1;
  repeated DataPoint memory_usage = 2;

  message DataPoint {
    int64 timestamp = 1;
    int64 value     = 2;
  }
}

message PersistentVolumeRegisterRequest {
  string cluster = 1;
  string name = 2;
  string identifier = 3;
  string plugin = 4;
  int64 size_gb = 5;
  string endpoint = 6;
}

message PersistentVolumeUnRegisterRequest {
  string cluster = 1;
  string name = 2;
}

message PersistentVolumeClaimRegisterRequest {
  string cluster = 1;
  string name = 2;
  int64 size_gb = 3;
  string namespace = 4;
}

message PersistentVolumeClaimUnRegisterRequest {
  string cluster = 1;
  string name = 2;
  string namespace = 3;
}

message Alert {
    Meta meta = 1;
    AlertSpec spec = 2;
    string status = 3;

    message AlertSpec {
        IcingaParam icinga_param = 1;
        string check_command = 2;
        repeated NotifierParam notifier_params= 3;
        map<string, string> vars = 4;

        message IcingaParam {
           int64 check_interval_sec = 1;
           int64 alert_interval_sec = 2;
        }

        message NotifierParam {
            string state = 1;
            string user_uid = 2;
            string method = 3;
        }
    }
}

message Role {
  Meta meta = 1;
  repeated Rule rules = 2;
}

message RoleBinding {
  Meta meta = 1;
  repeated Subject subjects = 2;
  ObjectReference role_ref = 3;
}

message ClusterRole {
  Meta meta = 1;
  repeated Rule rules = 2;
}

message ClusterRoleBinding {
  Meta meta = 1;
  repeated Subject subjects = 2;
  ObjectReference role_ref = 3;
}

message Rule {
  repeated string verbs = 1;
  repeated string api_groups = 2;
  repeated string resources = 3;
  repeated string resource_names = 4;
  repeated string non_resource_urls = 5;
}

message Subject {
  string kind = 1;
  string api_version = 2;
  string name = 3;
  string namespace = 4;
}

message CronJob {
    Meta meta = 1;
    Spec space = 2;
    Status status = 3;

    message Spec {
        string schedule = 1;
        int64 starting_deadline_seconds = 2;
        string concurrency_policy = 3;
        bool suspend = 4;
        JobSpec template = 5;
    }

    message Status {
        repeated ObjectReference active = 1;
        int64 last_schedule_time = 2;
    }
}

message Certificate {
  Meta meta = 1;
  Spec spec = 2;
  Status status = 3;

  message Spec {
    // Obtain a single certificate for all the domains. The first Domain provided wiil
    // be counted as Name and other domains will be in SANs.
    repeated string domains = 1;

    // Provider to resolve challange. Valid Providers are
    // "http":
    // "cloudflare":
    // "digitalocean":
    // "dnsimple":
    // "dyn":
    // "gandi":
    // "googlecloud":
    // "linode":
    // "namecheap":
    // "ovh":
    // "pdns":
    // "rfc2136":
    // "route53":
    // "vultr":
    string provider = 2;
    string email = 3;
    ObjectReference HTTP_provider_ingress_reference = 4;

    // ProviderCredentialSecret Must Contain Secrets for that specific Providers.
    // All the Key names for DNS providers needs to maintain the following formate:
    //
    // http
    // HTTP Provider needs an Ingress or ExtendedIngress reference in HTTP_provider_ingress_reference.
    //
    // cloudflare
    // CLOUDFLARE_EMAIL: The email of the cloudflare user
    // CLOUDFLARE_API_KEY: The API key corresponding to the email
    // 
    // digitalocean
    // DO_AUTH_TOKEN: The digital ocean authorization token
    // 
    // dnsimple
    // DNSIMPLE_EMAIL: The email fo the DNSimple user
    // DNSIMPLE_API_KEY: The API key corresponding to the email
    // 
    // dnsmadeeasy
    // DNSMADEEASY_API_KEY: The API key for DNS Made Easy
    // DNSMADEEASY_API_SECRET: The api secret corresponding with the API key
    // DNSMADEEASY_SANDBOX: A boolean flag, if set to true or 1, requests will be sent to the sandbox API
    // 
    // dyn
    // DYN_CUSTOMER_NAME: The customer name of the Dyn user
    // DYN_USER_NAME: The user name of the Dyn user
    // DYN_PASSWORD: The password of the Dyn user
    // 
    // gandi
    // GANDI_API_KEY: The API key for Gandi
    // 
    // googlecloud
    // GCE_PROJECT: The name of the Google Cloud project to use
    //
    // linode
    // LINODE_API_KEY: API key for linode
    //
    // namecheap
    // NAMECHEAP_API_USER: The username of the namecheap user
    // NAMECHEAP_API_KEY: The API key corresponding with the namecheap user
    // 
    // ovh
    // OVH_ENDPOINT: The URL of the API endpoint to use
    // OVH_APPLICATION_KEY: The application key
    // OVH_APPLICATION_SECRET: The secret corresponding to the application key
    // OVH_CONSUMER_KEY: The consumer key
    // 
    // pdns
    // PDNS_API_KEY: The API key to use
    // 
    // rfc2136
    // RFC2136_NAMESERVER: The network address of the provider, in the form of "host" or "host:port"
    // RFC2136_TSIG_ALGORITHM: The algorithm to use for TSIG authentication.
    // RFC2136_TSIG_KEY: The key to use for TSIG authentication.
    // RFC2136_TSIG_SECRET: The secret to use for TSIG authentication.
    // 
    // route53
    // AWS_ACCESS_KEY_ID: The access key ID
    // AWS_SECRET_ACCESS_KEY: The secret corresponding to the access key
    // 
    // vultr
    // VULTR_API_KEY: The API key to use
    string provider_credential_secret_name = 5;
    string ACME_user_secret_name = 6;

    // Provides Custom acme server url to issue certificates. If empty it
    // uses let's encrypt servers.
    string ACME_serverURL = 7;
  }

  message Status {
    bool certificate_obtained = 1;
    string message = 2;
    int64 created_at = 3;
    string ACME_user_secret_name = 4;
    ACMECertificateDetails details = 5;

    message ACMECertificateDetails {
      string domain = 1;
      string certURL = 2;
      string cert_stableURL = 3;
      string account_ref = 4;
    }
  }
}

// TODO
// The following values are copied from kubernetes/pkg/api/v1/generated.proto
// Those values should be removed and use by importing those protobuf
// while kubernetes completely moved to protobuf.

// PersistentVolumeSource is similar to VolumeSource but meant for the
// administrator who creates PVs. Exactly one of its members must be set.
message PersistentVolumeSource {
  // GCEPersistentDisk represents a GCE Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod. Provisioned by an admin.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#gcepersistentdisk
  GCEPersistentDiskVolumeSource gcePersistentDisk = 1;

  // AWSElasticBlockStore represents an AWS Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#awselasticblockstore
  AWSElasticBlockStoreVolumeSource awsElasticBlockStore = 2;

  // HostPath represents a directory on the host.
  // Provisioned by a developer or tester.
  // This is useful for single-node development and testing only!
  // On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#hostpath
  HostPathVolumeSource hostPath = 3;

  // Glusterfs represents a Glusterfs volume that is attached to a host and
  // exposed to the pod. Provisioned by an admin.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/glusterfs/README.md
  GlusterfsVolumeSource glusterfs = 4;

  // NFS represents an NFS mount on the host. Provisioned by an admin.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#nfs
  NFSVolumeSource nfs = 5;

  // RBD represents a Rados Block Device mount on the host that shares a pod's lifetime.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md
  RBDVolumeSource rbd = 6;

  // ISCSI represents an ISCSI Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod. Provisioned by an admin.
  ISCSIVolumeSource iscsi = 7;

  // Cinder represents a cinder volume attached and mounted on kubelets host machine
  // More info: http://releases.k8s.io/release-1.4/examples/mysql-cinder-pd/README.md
  CinderVolumeSource cinder = 8;

  // CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
  CephFSVolumeSource cephfs = 9;

  // FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
  FCVolumeSource fc = 10;

  // Flocker represents a Flocker volume attached to a kubelet's host machine and exposed to the pod for its usage. This depends on the Flocker control service being running
  FlockerVolumeSource flocker = 11;

  // FlexVolume represents a generic volume resource that is
  // provisioned/attached using an exec based plugin. This is an
  // alpha feature and may change in future.
  FlexVolumeSource flexVolume = 12;

  // AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
  AzureFileVolumeSource azureFile = 13;

  // VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
  VsphereVirtualDiskVolumeSource vsphereVolume = 14;

  // Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
  QuobyteVolumeSource quobyte = 15;

  // AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
  AzureDiskVolumeSource azureDisk = 16;
}

// Represents a Persistent Disk resource in AWS.
//
// An AWS EBS disk must exist before mounting to a container. The disk
// must also be in the same AWS zone as the kubelet. An AWS EBS disk
// can only be mounted as read/write once. AWS EBS volumes support
// ownership management and SELinux relabeling.
message AWSElasticBlockStoreVolumeSource {
  // Unique ID of the persistent disk resource in AWS (Amazon EBS volume).
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#awselasticblockstore
  string volumeID = 1;

  // Filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#awselasticblockstore
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  string fsType = 2;

  // The partition in the volume that you want to mount.
  // If omitted, the default is to mount by volume name.
  // Examples: For volume /dev/sda1, you specify the partition as "1".
  // Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
  int32 partition = 3;

  // Specify "true" to force and set the ReadOnly property in VolumeMounts to "true".
  // If omitted, the default is "false".
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#awselasticblockstore
  bool readOnly = 4;
}

// Represents a host path mapped into a pod.
// Host path volumes do not support ownership management or SELinux relabeling.
message HostPathVolumeSource {
  // Path of the directory on the host.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#hostpath
  string path = 1;
}

// Represents an NFS mount that lasts the lifetime of a pod.
// NFS volumes do not support ownership management or SELinux relabeling.
message NFSVolumeSource {
  // Server is the hostname or IP address of the NFS server.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#nfs
  string server = 1;

  // Path that is exported by the NFS server.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#nfs
  string path = 2;

  // ReadOnly here will force
  // the NFS export to be mounted with read-only permissions.
  // Defaults to false.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#nfs
  bool readOnly = 3;
}

// Represents a Fibre Channel volume.
// Fibre Channel volumes can only be mounted as read/write once.
// Fibre Channel volumes support ownership management and SELinux relabeling.
message FCVolumeSource {
  // Required: FC target worldwide names (WWNs)
  repeated string targetWWNs = 1;

  // Required: FC target lun number
  int32 lun = 2;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  string fsType = 3;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  bool readOnly = 4;
}

// FlexVolume represents a generic volume resource that is
// provisioned/attached using an exec based plugin. This is an alpha feature and may change in future.
message FlexVolumeSource {
  // Driver is the name of the driver to use for this volume.
  string driver = 1;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
  string fsType = 2;

  // Optional: SecretRef is reference to the secret object containing
  // sensitive information to pass to the plugin scripts. This may be
  // empty if no secret object is specified. If the secret object
  // contains more than one secret, all secrets are passed to the plugin
  // scripts.
  ObjectReference secretRef = 3;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  bool readOnly = 4;

  // Optional: Extra command options if any.
  map<string, string> options = 5;
}

// Represents a Flocker volume mounted by the Flocker agent.
// Flocker volumes do not support ownership management or SELinux relabeling.
message FlockerVolumeSource {
  // Required: the volume name. This is going to be store on metadata -> name on the payload for Flocker
  string datasetName = 1;
}

// Represents a Persistent Disk resource in Google Compute Engine.
//
// A GCE PD must exist before mounting to a container. The disk must
// also be in the same GCE project and zone as the kubelet. A GCE PD
// can only be mounted as read/write once or read-only many times. GCE
// PDs support ownership management and SELinux relabeling.
message GCEPersistentDiskVolumeSource {
  // Unique name of the PD resource in GCE. Used to identify the disk in GCE.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#gcepersistentdisk
  string pdName = 1;

  // Filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#gcepersistentdisk
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  string fsType = 2;

  // The partition in the volume that you want to mount.
  // If omitted, the default is to mount by volume name.
  // Examples: For volume /dev/sda1, you specify the partition as "1".
  // Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#gcepersistentdisk
  int32 partition = 3;

  // ReadOnly here will force the ReadOnly setting in VolumeMounts.
  // Defaults to false.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#gcepersistentdisk
  bool readOnly = 4;
}

// Represents a volume that is populated with the contents of a git repository.
// Git repo volumes do not support ownership management.
// Git repo volumes support SELinux relabeling.
message GitRepoVolumeSource {
  // Repository URL
  string repository = 1;

  // Commit hash for the specified revision.
  string revision = 2;

  // Target directory name.
  // Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
  // git repository.  Otherwise, if specified, the volume will contain the git repository in
  // the subdirectory with the given name.
  string directory = 3;
}

// Represents a Glusterfs mount that lasts the lifetime of a pod.
// Glusterfs volumes do not support ownership management or SELinux relabeling.
message GlusterfsVolumeSource {
  // EndpointsName is the endpoint name that details Glusterfs topology.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/glusterfs/README.md#create-a-pod
  string endpoints = 1;

  // Path is the Glusterfs volume path.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/glusterfs/README.md#create-a-pod
  string path = 2;

  // ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions.
  // Defaults to false.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/glusterfs/README.md#create-a-pod
  bool readOnly = 3;
}

// Represents a Rados Block Device mount that lasts the lifetime of a pod.
// RBD volumes support ownership management and SELinux relabeling.
message RBDVolumeSource {
  // A collection of Ceph monitors.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it
  repeated string monitors = 1;

  // The rados image name.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it
  string image = 2;

  // Filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#rbd
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  string fsType = 3;

  // The rados pool name.
  // Default is rbd.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it.
  string pool = 4;

  // The rados user name.
  // Default is admin.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it
  string user = 5;

  // Keyring is the path to key ring for RBDUser.
  // Default is /etc/ceph/keyring.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it
  string keyring = 6;

  // SecretRef is name of the authentication secret for RBDUser. If provided
  // overrides keyring.
  // Default is nil.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it
  ObjectReference secretRef = 7;

  // ReadOnly here will force the ReadOnly setting in VolumeMounts.
  // Defaults to false.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it
  bool readOnly = 8;
}

// Represents an ISCSI disk.
// ISCSI volumes can only be mounted as read/write once.
// ISCSI volumes support ownership management and SELinux relabeling.
message ISCSIVolumeSource {
  // iSCSI target portal. The portal is either an IP or ip_addr:port if the port
  // is other than default (typically TCP ports 860 and 3260).
  string targetPortal = 1;

  // Target iSCSI Qualified Name.
  string iqn = 2;

  // iSCSI target lun number.
  int32 lun = 3;

  // Optional: Defaults to 'default' (tcp). iSCSI interface name that uses an iSCSI transport.
  string iscsiInterface = 4;

  // Filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#iscsi
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  string fsType = 5;

  // ReadOnly here will force the ReadOnly setting in VolumeMounts.
  // Defaults to false.
  bool readOnly = 6;
}

// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
message AzureFileVolumeSource {
  // the name of secret that contains Azure Storage Account Name and Key
  string secretName = 1;

  // Share Name
  string shareName = 2;

  // Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  bool readOnly = 3;
}

// Represents a vSphere volume resource.
message VsphereVirtualDiskVolumeSource {
  // Path that identifies vSphere volume vmdk
  string volumePath = 1;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  string fsType = 2;
}

// Represents a Quobyte mount that lasts the lifetime of a pod.
// Quobyte volumes do not support ownership management or SELinux relabeling.
message QuobyteVolumeSource {
  // Registry represents a single or multiple Quobyte Registry services
  // specified as a string as host:port pair (multiple entries are separated with commas)
  // which acts as the central registry for volumes
  string registry = 1;

  // Volume is a string that references an already created Quobyte volume by name.
  string volume = 2;

  // ReadOnly here will force the Quobyte volume to be mounted with read-only permissions.
  // Defaults to false.
  bool readOnly = 3;

  // User to map volume access to
  // Defaults to serivceaccount user
  string user = 4;

  // Group to map volume access to
  // Default is no group
  string group = 5;
}

// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
message AzureDiskVolumeSource {
  // The Name of the data disk in the blob storage
  string diskName = 1;

  // The URI the data disk in the blob storage
  string diskURI = 2;

  // Host Caching mode: None, Read Only, Read Write.
  string cachingMode = 3;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  string fsType = 4;

  // Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  bool readOnly = 5;
}

// Represents a cinder volume resource in Openstack.
// A Cinder volume must exist before mounting to a container.
// The volume must also be in the same region as the kubelet.
// Cinder volumes support ownership management and SELinux relabeling.
message CinderVolumeSource {
  // volume id used to identify the volume in cinder
  // More info: http://releases.k8s.io/release-1.4/examples/mysql-cinder-pd/README.md
  string volumeID = 1;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: http://releases.k8s.io/release-1.4/examples/mysql-cinder-pd/README.md
  string fsType = 2;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // More info: http://releases.k8s.io/release-1.4/examples/mysql-cinder-pd/README.md
  bool readOnly = 3;
}

// Represents a Ceph Filesystem mount that lasts the lifetime of a pod
// Cephfs volumes do not support ownership management or SELinux relabeling.
message CephFSVolumeSource {
  // Required: Monitors is a collection of Ceph monitors
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/cephfs/README.md#how-to-use-it
  repeated string monitors = 1;

  // Optional: Used as the mounted root, rather than the full Ceph tree, default is /
  string path = 2;

  // Optional: User is the rados user name, default is admin
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/cephfs/README.md#how-to-use-it
  string user = 3;

  // Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/cephfs/README.md#how-to-use-it
  string secretFile = 4;

  // Optional: SecretRef is reference to the authentication secret for User, default is empty.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/cephfs/README.md#how-to-use-it
  ObjectReference secretRef = 5;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/cephfs/README.md#how-to-use-it
  bool readOnly = 6;
}