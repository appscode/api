syntax = "proto3";

package appscode.kubernetes.v1beta2;

option go_package = "v1beta2";

option java_multiple_files = true;
option java_outer_classname = "ClientProto";
option java_package = "com.appscode.api.kubernetes.v1beta2";

import "google/api/annotations.proto";
import "appscode/api/annotations.proto";
import "appscode/api/dtypes/types.proto";

service Clients {
  rpc List(ListResourceRequest) returns (ListResourceResponse){
    option (google.api.http) = {
      get : "/_appscode/api/kubernetes/v1beta2/clusters/{cluster}/{type}/json"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Describe(DescribeResourceRequest) returns (DescribeResourceResponse){
    option (google.api.http) = {
      get : "/_appscode/api/kubernetes/v1beta2/clusters/{cluster}/{type}/{name}/json"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Create(CreateResourceRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      post: "/_appscode/api/kubernetes/v1beta2/clusters/{cluster}/{type}/json"
      body : "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Delete(DeleteResourceRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      delete: "/_appscode/api/kubernetes/v1beta2/clusters/{cluster}/{type}/{name}/json"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Update(UpdateResourceRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      put : "/_appscode/api/kubernetes/v1beta2/clusters/{cluster}/{type}/{name}/json"
      body : "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Copy(CopyResourceRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      put : "/_appscode/api/kubernetes/v1beta2/actions/copy/json"
      body : "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  // Followings are type specific actions api, that can be applied upon fixed resources.
  // TODO: (@sadlil) Consider seperating them.
  rpc EditConfigMap(ConfigMapEditRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      post : "/_appscode/api/kubernetes/v1beta2/clusters/{cluster}/namespaces/{namespace}/configmaps/{name}/actions/edit/json"
      body : "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc EditSecret(SecretEditRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      post : "/_appscode/api/kubernetes/v1beta2/clusters/{cluster}/namespaces/{namespace}/secrets/{name}/actions/edit/json"
      body : "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc RegisterPersistentVolume(PersistentVolumeRegisterRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      post: "/_appscode/api/kubernetes/v1beta2/clusters/{cluster}/persistentvolumes/{name}/actions/register/json"
      body: "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc UnregisterPersistentVolume(PersistentVolumeUnRegisterRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      delete: "/_appscode/api/kubernetes/v1beta2/clusters/{cluster}/persistentvolumes/{name}/actions/unregister/json"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc RegisterPersistentVolumeClaim(PersistentVolumeClaimRegisterRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      post: "/_appscode/api/kubernetes/v1beta2/clusters/{cluster}/persistentvolumeclaims/{name}/actions/register/json"
      body: "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc UnregisterPersistentVolumeClaim(PersistentVolumeClaimUnRegisterRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      delete: "/_appscode/api/kubernetes/v1beta2/clusters/{cluster}/persistentvolumeclaims/{name}/actions/unregister/json"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }
}

service Disks {
  rpc List(DiskListRequest) returns (DiskListResponse) {
    option (google.api.http) = {
      get: "/_appscode/api/cloud/v1beta2/disks/json"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Describe(DiskDescribeRequest) returns (DiskDescribeResponse) {
    option (google.api.http) = {
      get: "/_appscode/api/cloud/v1beta2/disks/{name}/json"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Create(DiskCreateRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      post: "/_appscode/api/cloud/v1beta2/disks/json"
      body: "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Delete(DiskDeleteRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      delete: "/_appscode/api/cloud/v1beta2/disks/{uid}/json"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }
}

message ListResourceRequest {
  string cluster = 1;
  string type = 2;
  string namespace = 3;
  bool include_metrics = 4;
  Ancestor ancestor = 5;
  // map type is not supported by grpc-gateway as query params.
  // https://github.com/grpc-ecosystem/grpc-gateway/blob/master/runtime/query.go#L57
  // https://github.com/grpc-ecosystem/grpc-gateway/issues/316
  // map<string, string> label_selector = 6;
  // example label_selector=environment=production,tier=frontend
  string label_selector = 7;

  message Ancestor {
      string type = 1;
      string name = 2;
  }
}

message ListResourceResponse {
  dtypes.Status status = 1;
  KubeResourceList resources = 2;
}

message DescribeResourceRequest {
  string cluster = 1;
  string type = 2;
  string namespace = 3;
  string name = 4;
  string raw = 5;
  bool include_metrics = 6;
}

message DescribeResourceResponse {
  dtypes.Status status = 1;
  KubeResource resource = 2;
}

message UpdateResourceRequest {
  string cluster = 1;
  string type = 2;
  string namespace = 3;
  string name = 4;
  Raw raw = 5;
}

message ConfigMapEditRequest {
  string cluster = 1;
  string namespace = 2;
  string name = 3;
  map<string, string> add = 4;
  map<string, string> update = 5;
  repeated string deleted = 6;
}

message SecretEditRequest {
  string cluster = 1;
  string namespace = 2;
  string name = 3;
  map<string, string>  add = 4;
  map<string, string>  update = 5;
  repeated string deleted = 6;
}

message CopyResourceRequest {
  KubeObject source = 1;
  KubeObject destination = 2;
}

message CreateResourceRequest {
  string cluster = 1;
  string type = 2;
  string name = 4;
  Raw raw = 5;
}

message DeleteResourceRequest {
  string cluster = 1;
  string type = 2;
  string namespace = 3;
  string name = 4;
}

message KubeResourceList {
  string type = 1;
  oneof  resource {
    Apps apps = 2;
    ConfigMaps config_maps = 3;
    DaemonSets daemon_sets = 4;
    Deployments deployments = 5;
    Jobs jobs = 6;
    Namespaces namespaces = 7;
    Nodes nodes = 8;
    StatefulSets stateful_sets = 9;
    Pods pods = 10;
    ReplicaSets replica_sets = 11;
    Services services = 12;
    Secrets secrets = 13;
    ReplicationControllers replication_controllers = 14;
    StorageClasses storage_classes = 15;
    PersistentVolumes persistent_volumes = 16;
    PersistentVolumeClaims persistent_volume_claims = 17;
    Alerts alerts = 18;
    Roles roles = 19;
    ClusterRoles cluster_roles = 20;
    RoleBindings role_bindings = 21;
    ClusterRoleBindings cluster_role_bindings = 22;
    Certificates certificates = 23;
    CronJobs cron_jobs = 24;
    Backups backups = 25;
    Postgreses postgreses = 26;
    Elastics elastics = 27;
    DeletedDatabases deleted_databases = 28;
    DatabaseSnapshots database_snapshots = 29;
  }

  message Apps {
    repeated App items = 1;
  }

  message ConfigMaps {
    repeated ConfigMap items = 1;
  }

  message DaemonSets {
    repeated DaemonSet items = 1;
  }

  message Deployments {
    repeated Deployment items = 1;
  }

  message Jobs {
    repeated Job items = 1;
  }

  message Namespaces {
    repeated Namespace items = 1;
  }

  message Nodes {
    repeated Node items = 1;
  }

  message StatefulSets {
    repeated StatefulSet items = 1;
  }

  message Pods {
    repeated Pod items = 1;
  }

  message ReplicaSets {
    repeated ReplicaSet items = 1;
  }

  message Services {
    repeated Service items = 1;
  }

  message Secrets {
    repeated Secret items = 1;
  }

  message ReplicationControllers {
    repeated ReplicationController items = 1;
  }

  message StorageClasses {
      repeated StorageClass items = 1;
  }

  message PersistentVolumes {
    repeated PersistentVolume items = 1;
  }

  message PersistentVolumeClaims {
    repeated PersistentVolumeClaim items = 1;
  }

  message Alerts {
    repeated Alert items = 1;
  }

  message Roles {
    repeated Role items = 1;
  }

  message ClusterRoles {
    repeated ClusterRole items = 1;
  }

  message RoleBindings {
    repeated RoleBinding items = 1;
  }

  message ClusterRoleBindings {
    repeated ClusterRoleBinding items = 1;
  }

  message Certificates {
    repeated Certificate items = 1;
  }

  message CronJobs {
    repeated CronJob items = 1;
  }

  message Postgreses {
    repeated Postgres items = 1;
  }

  message Elastics {
    repeated Elastic items = 1;
  }

  message DeletedDatabases {
    repeated DeletedDatabase items = 1;
  }

  message DatabaseSnapshots {
    repeated DatabaseSnapshot items = 2;
  }

  message Backups {
    repeated Backup items = 1;
  }
}

// TODO: (@sadlil): when kubernetes moves to protobuf completely import fileds from there.
message KubeResource {
  string type = 1;
  oneof  resource {
    App app = 2;
    ConfigMap config_map = 3;
    DaemonSet daemon_set = 4;
    Deployment deployment = 5;
    Job job = 6;
    Namespace namespace = 7;
    Node node = 8;
    StatefulSet stateful_set = 9;
    Pod pod = 10;
    ReplicaSet replica_set = 11;
    Service service = 12;
    Secret secret = 13;
    ReplicationController replication_controller = 14;
    StorageClass storage_class = 15;
    PersistentVolume persistent_volume = 16;
    PersistentVolumeClaim persistent_volume_claim = 17;
    Alert alert = 20;
    Role role = 21;
    ClusterRole cluster_role = 22;
    RoleBinding role_binding = 23;
    ClusterRoleBinding cluster_role_binding = 24;
    Certificate certificate = 25;
    CronJob cron_job = 26;
    Backup backup = 27;
    Postgres postgres = 28;
    Elastic elastic = 29;
    DeletedDatabase deleted_database = 30;
    DatabaseSnapshot database_snapshot = 31;
  }
  repeated Event events = 18;
  Raw raw = 19;
}

message Meta {
  string name = 1;
  string namespace = 2;
  string self_links = 3;
  string resource_version = 4;
  int64 created_at = 5;
  int64 generation = 6;
  map<string, string> labels = 7;
  map<string, string> annotations = 8;
  string uid = 9;
}

message KubeObject {
  string cluster = 1;
  string type = 2;
  string namespace = 3;
  string name = 4;
}

message IcingaState {
    int32 OK = 1;
    int32 Warning = 2;
    int32 Critical = 3;
    int32 Unknown = 4;
}

message App {
  string cluster = 1;
  string type = 2;
  string namespace = 3;
  string name = 4;
  Service app = 5;
  map<string, string> links = 6;
  int64 created_at = 7;
  string cluster_ip = 8;
  IcingaState icinga_state = 9;
}

message PodSpec {
  repeated  Volume  volumes = 1;
  repeated  Container containers = 2;
  map<string, string> node_selectors = 3;
  string service_account_name = 4;
  string node_name = 5;
  repeated string image_pull_secrets = 6;

  message Container {
    string name  = 1;
    string image = 2;
    repeated string commands = 3;
    repeated VolumeMount volume_mounts = 4;
    repeated string args = 5;
    string working_dir = 6;
    repeated EnvVar env = 7;

    message VolumeMount {
      string name = 1;
      bool read_only = 2;
      string mount_path = 3;
    }
  }

  message Volume {
    string name = 1;
    string host_path = 2;
  }
}

message Raw {
  string format = 1;
  string data = 2;
}

message ConfigMap {
  Meta meta = 1;
  map<string, string> data = 2;
}

message Job {
  Meta meta = 1;
  string app = 2;
  JobSpec spec = 3;
  Status status = 4;

  message Status {
    int64 start_time = 1;
    int64 completion_time = 2;
    int32 active = 3;
    int32 succeeded = 4;
    int32 failed = 5;
    repeated ResourceCondition conditions = 6;
  }
}

message JobSpec {
    int32 parallelism = 1;
    int32 completions = 2;
    PodSpec template = 3;
    int64 active_deadline_seconds = 4;

}

message Namespace {
  Meta meta = 1;
  Status status = 2;
  NamespaceSpec spec = 3;

  message NamespaceSpec {
    repeated string finalizers = 1;
  }

  message Status {
    string phase = 1;
  }
}

message Node {
  Meta meta = 1;
  Spec spec = 2;
  bool is_master = 3;
  NodeStatus status = 4;
  Metrics metrics = 5;

  message Spec {
    string external_id = 1;
    string provider_id = 2;
    bool unschedulable = 3;
    string podCIDR = 4;
  }

  message NodeStatus {
    Capacity capacity = 1;
    string phase = 2;
    NodeSystemInfo node_info = 3;
    Capacity allocatable = 4;
    repeated ResourceCondition conditions = 5;
    repeated NodeAddress address = 6;
    repeated ContainerImage images = 7;
    repeated string volumes_in_use = 8;
    repeated AttachedVolume volumes_attached = 9;

    message Capacity {
      int64 cpu = 1;
      int64 memory = 2;
      int64 pods = 3;
      string storage = 4;
    }

    message NodeSystemInfo {
      string machineID = 6;
      string systemUUID = 7;
      string bootID = 8;
      string kernel_version = 1;
      string os_image = 2;
      string container_runtime_version = 3;
      string kubelet_version = 4;
      string kube_proxy_version = 5;
      string operating_system = 9;
      string architecture = 10;
    }

    message NodeAddress {
      string type = 1;
      string address = 2;
    }

    message ContainerImage {
      repeated string names = 1;
      int64 size_bytes = 2;
    }

    message AttachedVolume {
      string name = 1;
      string device_path = 2;
    }
  }
}

message Pod {
  Meta meta = 1;
  string app = 2;
  PodSpec spec = 3;
  PodStatus status = 4;
  Metrics metrics = 5;

  message PodStatus {
    string phase = 1;
    string message = 2;
    string reason = 3;
    string hostIP = 4;
    string podIP = 5;
    repeated ResourceCondition conditions = 6;
    int64 start_time = 7;
  }
}

message PersistentVolume {
  Meta meta = 1;
  PersistentVolumeSpec spec = 2;
  PersistentVolumeStatus status = 3;

  message PersistentVolumeSpec {
    map <string, string> capacity = 1;
    repeated string access_modes = 2;
    string persistent_volume_reclaim_policy = 3;
    ObjectReference claim_ref = 4;
    PersistentVolumeSource persistent_volume_source = 5;
  }

  message PersistentVolumeStatus {
    string phase = 1;
    string message = 2;
    string reason = 3;
  }
}

message PersistentVolumeClaim {
  Meta meta = 1;
  PersistentVolumeClaimSpec spec = 2;
  PersistentVolumeClaimStatus status = 3;

  message PersistentVolumeClaimStatus {
    string phase = 1;
    repeated string access_modes = 2;
    map <string, string> capacity = 3;
  }
}

message PersistentVolumeClaimSpec {
  repeated string access_modes = 1;
  ResourceRequirements resources = 2;
  string volume_name = 3;

  message ResourceRequirements {
    map<string, string> limits = 1;
    map<string, string> requests = 2;
  }
}

message ObjectReference {
  string kind = 1;
  string namespace = 2;
  string name = 3;
  string uid = 4;
  string API_version = 5;
  string resource_version = 6;
}

message Service {
  Meta meta = 1;
  string app = 2;
  Spec spec = 3;
  Status status = 4;

  message Spec {
    string type = 1;
    repeated Port ports = 2;
    map<string, string> selectors = 3;
    string clusterIP = 4;
    repeated string externalIPs = 5;
    string loadbalancerIP = 6;
    string external_name = 7;
    string session_affinity = 8;
    repeated string load_balancer_source_ranges = 9;

    message Port {
      string name = 1;
      string protocol = 2;
      int32 port = 3;
      string target_port = 4;
      int32 node_port = 5;
    }
  }

  message Status {
    repeated LoadBalancerIngress loadbalancer_ingresses = 1;

    message LoadBalancerIngress {
      string host_name = 1;
      string IP = 2;
    }
  }
}

message Secret {
  Meta meta = 1;
  map<string, string> data = 2;
  string type = 3;
}

message ReplicationController {
  Meta meta = 1;
  string app = 2;
  Spec spec = 3;
  Status status = 4;

  message Spec {
    int32 desired_replicas = 1;
    map<string, string> selectors = 2;
    PodSpec pod_template = 3;
  }

  message Status {
    int32 current_replicas = 1;
    int64 observed_generation = 2;
  }
}

message ReplicaSet {
  Meta meta = 1;
  string app = 2;
  Spec spec = 3;
  Status status = 4;

  message Spec {
    int32 desired_replicas = 1;
    LabelSelector selector = 2;
    PodSpec pod_template = 3;
  }

  message Status {
    int32 current_replicas = 1;
    int64 observed_generation = 2;
  }
}

message DaemonSet {
  Meta meta = 1;
  string app = 2;
  Spec spec = 3;
  Status status = 4;

  message Spec {
    LabelSelector selector = 1;
    PodSpec pod_template = 2;
  }

  message Status {
    int32 current_number_scheduled = 1;
    int32 number_misscheduled = 2;
    int32 desired_number_scheduled = 3;
  }
}

message Deployment {
  Meta meta = 1;
  string app = 2;
  Spec spec = 3;
  DeploymentStatus status = 4;

  message Spec {
    int32 desired_replicas = 1;
    LabelSelector selector = 2;
    PodSpec pod_template = 3;
    int32 min_ready_seconds = 4;
    int32 revision_history_limit = 5;
    bool paused = 6;
    RollbackConfig rollback_to = 7;
    int32 progress_deadline_seconds = 8;
    DeploymentStrategy strategy = 9;

    message DeploymentStrategy {
        string type = 1;
        RollingUpdateDeployment rolling_update = 2;
    }

    message RollingUpdateDeployment {
      string max_unavailable = 1;
      string max_surge = 2;
    }

    message RollbackConfig {
      int64 revision = 1;
    }
  }

  message DeploymentStatus {
    int64 observed_generation = 1;
    int32 replicas = 2;
    int32 updated_replicas = 3;
    int32 available_replicas = 4;
    int32 unavailable_replicas = 5;
    repeated ResourceCondition conditions = 6;
  }
}

message StatefulSet {
  Meta meta = 1;
  string app = 2;
  Spec spec = 3;
  Status status = 4;

  message Spec {
    int32 desired_replicas = 1;
    LabelSelector selector = 2;
    PodSpec pod_template = 3;
    string service_name = 4;
  }

  message Status {
    int32 current_replicas = 1;
    int64 observed_generation = 2;
  }
}

message StorageClass {
    Meta meta = 1;
    string provisioner = 2;
    map<string, string> parameters = 3;
}

message LabelSelector {
  map<string, string> match_labels = 1;
}

message Event {
  Meta meta = 1;
  string reason = 2;
  string message = 3;
  EventSource source = 4;
  int64 first_timestamp = 5;
  int64 last_timestamp = 6;
  int32 count = 7;
  string type = 8;
}

message EventSource {
  string componenet = 1;
  string host = 2;
}

message Metrics {
  repeated DataPoint cpu_usage = 1;
  repeated DataPoint memory_usage = 2;

  message DataPoint {
    int64 timestamp = 1;
    int64 value     = 2;
  }
}

message PersistentVolumeRegisterRequest {
  string cluster = 1;
  string name = 2;
  string identifier = 3;
  string plugin = 4;
  int64 size_gb = 5;
  string endpoint = 6;
}

message PersistentVolumeUnRegisterRequest {
  string cluster = 1;
  string name = 2;
}

message PersistentVolumeClaimRegisterRequest {
  string cluster = 1;
  string name = 2;
  int64 size_gb = 3;
  string namespace = 4;
}

message PersistentVolumeClaimUnRegisterRequest {
  string cluster = 1;
  string name = 2;
  string namespace = 3;
}

message Alert {
    Meta meta = 1;
    AlertSpec spec = 2;
    string status = 3;

    message AlertSpec {
        IcingaParam icinga_param = 1;
        string check_command = 2;
        repeated NotifierParam notifier_params= 3;
        map<string, string> vars = 4;

        message IcingaParam {
           int64 check_interval_sec = 1;
           int64 alert_interval_sec = 2;
        }

        message NotifierParam {
            string state = 1;
            string user_uid = 2;
            string method = 3;
        }
    }
}

message Role {
  Meta meta = 1;
  repeated Rule rules = 2;
}

message RoleBinding {
  Meta meta = 1;
  repeated Subject subjects = 2;
  ObjectReference role_ref = 3;
}

message ClusterRole {
  Meta meta = 1;
  repeated Rule rules = 2;
}

message ClusterRoleBinding {
  Meta meta = 1;
  repeated Subject subjects = 2;
  ObjectReference role_ref = 3;
}

message Rule {
  repeated string verbs = 1;
  repeated string api_groups = 2;
  repeated string resources = 3;
  repeated string resource_names = 4;
  repeated string non_resource_urls = 5;
}

message Subject {
  string kind = 1;
  string api_version = 2;
  string name = 3;
  string namespace = 4;
}

message Backup {
  Meta meta = 1;
  Spec spec = 2;
  Status status = 3;
  message Spec {
    string schedule = 1;
    repeated string tags = 2;
    BackupSource source = 3;
    BackupDestination destination = 4;
    RetentionPolicy retention_policy = 5;

    message BackupSource {
      string volume_name = 1;
      string path = 2;
    }

    message BackupDestination {
      string path = 1;
      string  repository_secret_name = 2;
      PersistentVolumeSource volume = 3;
    }

    message RetentionPolicy {
      int32 keep_last_snapshots = 1;
      int32 keep_hourly_snapshots = 2;
      int32 keep_daily_snapshots = 3;
      int32 keep_weekly_snapshots = 4;
      int32 keep_monthly_snapshots = 5;
      int32 keep_yearly_snapshots = 6;
      repeated string keep_tags = 7;
      string retain_host_name = 8;
      repeated string retain_tags = 9;
    }
  }

  message Status {
    int64 first_backup_time = 1;
    int64 last_backup_time = 2;
    int64 last_successful_backup_time = 3;
    string last_backup_duration = 4;
    int64 backup_count = 5;
  }
}

message CronJob {
    Meta meta = 1;
    Spec spec = 2;
    Status status = 3;

    message Spec {
        string schedule = 1;
        int64 starting_deadline_seconds = 2;
        string concurrency_policy = 3;
        bool suspend = 4;
        JobSpec template = 5;
    }

    message Status {
        repeated ObjectReference active = 1;
        int64 last_schedule_time = 2;
    }
}

message Postgres {
  Meta meta = 1;
  Spec spec = 2;
  DatabaseStatus status = 3;

  message Spec {
    string version = 1;
    int32 replicas = 2;
    StorageSpec storage = 3;
    string service_account_name = 4;
    SecretVolumeSource database_secret = 5;
    map<string, string> node_selector = 6;
    InitialScriptSpec initial_script = 7;
    BackupScheduleSpec backup_schedule = 8;
    bool do_not_delete = 9;
  }
}

message Elastic {
  Meta meta = 1;
  Spec spec = 2;
  DatabaseStatus status = 3;

  message Spec {
    string version = 1;
    int32 replicas = 2;
    StorageSpec storage = 3;
    string service_account_name = 4;
    map<string, string> node_selector = 5;
    BackupScheduleSpec backup_schedule = 6;
    bool do_not_delete = 7;
  }
}

message DeletedDatabase {
  Meta meta = 1;
  Spec spec = 2;
  Status status = 3;

  message Spec {
    string database_name = 1;
    SecretVolumeSource auth_secret = 2;
    bool destroy = 3;
  }

  message Status {
    string message = 1;
    int64 created = 2;
    int64 success = 3;
  }
}

message DatabaseSnapshot {
  Meta meta = 1;
  Spec spec = 2;
  Status status = 3;

  message Spec {
    string database_name = 1;
    SnapshotSpec snapshot_spec = 2;
  }

  message Status {
    int64 start_time = 1;
    int64 completion_time = 2;
    string status = 3;
    string reason = 4;
  }
}

message DatabaseStatus {
  int32 replicas = 1;
  int32 available_replicas = 2;
}

message StorageSpec {
  string class = 1;
  PersistentVolumeClaimSpec persistent_volume_claim_spec = 2;
}

message InitialScriptSpec {
  string script_path = 1;
  PersistentVolumeSource volume_source = 2;
}

message BackupScheduleSpec {
  string cron_expression = 1;
  SnapshotSpec snapshot_spec = 2;
}

message SnapshotSpec {
  SecretVolumeSource storage_secret = 1;
  SecretVolumeSource database_secret = 2;
  string bucket_name = 3;
}

message Certificate {
  Meta meta = 1;
  Spec spec = 2;
  Status status = 3;

  message Spec {
    // Obtain a single certificate for all the domains. The first Domain provided wiil
    // be counted as Name and other domains will be in SANs.
    repeated string domains = 1;

    // Provider to resolve challange. Valid Providers are
    // "http":
    // "cloudflare":
    // "digitalocean":
    // "dnsimple":
    // "dyn":
    // "gandi":
    // "googlecloud":
    // "linode":
    // "namecheap":
    // "ovh":
    // "pdns":
    // "rfc2136":
    // "route53":
    // "vultr":
    string provider = 2;
    string email = 3;
    ObjectReference HTTP_provider_ingress_reference = 4;

    // ProviderCredentialSecret Must Contain Secrets for that specific Providers.
    // All the Key names for DNS providers needs to maintain the following formate:
    //
    // http
    // HTTP Provider needs an Ingress or ExtendedIngress reference in HTTP_provider_ingress_reference.
    //
    // cloudflare
    // CLOUDFLARE_EMAIL: The email of the cloudflare user
    // CLOUDFLARE_API_KEY: The API key corresponding to the email
    // 
    // digitalocean
    // DO_AUTH_TOKEN: The digital ocean authorization token
    // 
    // dnsimple
    // DNSIMPLE_EMAIL: The email fo the DNSimple user
    // DNSIMPLE_API_KEY: The API key corresponding to the email
    // 
    // dnsmadeeasy
    // DNSMADEEASY_API_KEY: The API key for DNS Made Easy
    // DNSMADEEASY_API_SECRET: The api secret corresponding with the API key
    // DNSMADEEASY_SANDBOX: A boolean flag, if set to true or 1, requests will be sent to the sandbox API
    // 
    // dyn
    // DYN_CUSTOMER_NAME: The customer name of the Dyn user
    // DYN_USER_NAME: The user name of the Dyn user
    // DYN_PASSWORD: The password of the Dyn user
    // 
    // gandi
    // GANDI_API_KEY: The API key for Gandi
    // 
    // googlecloud
    // GCE_PROJECT: The name of the Google Cloud project to use
    //
    // linode
    // LINODE_API_KEY: API key for linode
    //
    // namecheap
    // NAMECHEAP_API_USER: The username of the namecheap user
    // NAMECHEAP_API_KEY: The API key corresponding with the namecheap user
    // 
    // ovh
    // OVH_ENDPOINT: The URL of the API endpoint to use
    // OVH_APPLICATION_KEY: The application key
    // OVH_APPLICATION_SECRET: The secret corresponding to the application key
    // OVH_CONSUMER_KEY: The consumer key
    // 
    // pdns
    // PDNS_API_KEY: The API key to use
    // 
    // rfc2136
    // RFC2136_NAMESERVER: The network address of the provider, in the form of "host" or "host:port"
    // RFC2136_TSIG_ALGORITHM: The algorithm to use for TSIG authentication.
    // RFC2136_TSIG_KEY: The key to use for TSIG authentication.
    // RFC2136_TSIG_SECRET: The secret to use for TSIG authentication.
    // 
    // route53
    // AWS_ACCESS_KEY_ID: The access key ID
    // AWS_SECRET_ACCESS_KEY: The secret corresponding to the access key
    // 
    // vultr
    // VULTR_API_KEY: The API key to use
    string provider_credential_secret_name = 5;
    string ACME_user_secret_name = 6;

    // Provides Custom acme server url to issue certificates. If empty it
    // uses let's encrypt servers.
    string ACME_serverURL = 7;
  }

  message Status {
    bool certificate_obtained = 1;
    string message = 2;
    int64 created_at = 3;
    string ACME_user_secret_name = 4;
    ACMECertificateDetails details = 5;

    message ACMECertificateDetails {
      string domain = 1;
      string certURL = 2;
      string cert_stableURL = 3;
      string account_ref = 4;
    }
  }
}

message DiskListRequest {
  string cluster=1;
}

message DiskListResponse {
  dtypes.Status status = 1;
  repeated Disk disks = 2;
}

message DiskDescribeRequest {
  string cluster = 1;
  string name = 2;
  string provider = 3;
}

message DiskDescribeResponse {
  dtypes.Status status = 1;
  Disk disk = 2;
}

message DiskCreateRequest {
  string cluster = 1;
  string name = 2;
  string zone = 3;
  string disk_type = 4;
  int64 size_gb = 5;
}

message DiskDeleteRequest {
  string cluster = 1;
  string uid = 2;
}

message Disk {
  string name = 1;
  string id = 2;
  string provider = 3;
  int64 size_gb = 4;
  string type = 5;
  string zone = 6;
  string status = 7;
  repeated string users = 8;
  string kind = 9;
  string endpoint = 10;
  int64 iops = 11;
  PersistentVolume persistent_volume = 12;
  PersistentVolumeClaim persistent_volume_claim = 13;
}

message ResourceCondition {
  string type = 1;
  string status = 2;
  int64 last_heartbeat_time = 3;
  int64 last_transition_time = 4;
  string reason = 5;
  string message = 6;
}

// TODO
// The following values are copied from kubernetes/pkg/api/v1/generated.proto
// Those values should be removed and use by importing those protobuf
// while kubernetes completely moved to protobuf.

// PersistentVolumeSource is similar to VolumeSource but meant for the
// administrator who creates PVs. Exactly one of its members must be set.
message PersistentVolumeSource {
  // GCEPersistentDisk represents a GCE Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod. Provisioned by an admin.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#gcepersistentdisk
  GCEPersistentDiskVolumeSource gcePersistentDisk = 1;

  // AWSElasticBlockStore represents an AWS Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#awselasticblockstore
  AWSElasticBlockStoreVolumeSource awsElasticBlockStore = 2;

  // HostPath represents a directory on the host.
  // Provisioned by a developer or tester.
  // This is useful for single-node development and testing only!
  // On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#hostpath
  HostPathVolumeSource hostPath = 3;

  // Glusterfs represents a Glusterfs volume that is attached to a host and
  // exposed to the pod. Provisioned by an admin.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/glusterfs/README.md
  GlusterfsVolumeSource glusterfs = 4;

  // NFS represents an NFS mount on the host. Provisioned by an admin.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#nfs
  NFSVolumeSource nfs = 5;

  // RBD represents a Rados Block Device mount on the host that shares a pod's lifetime.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md
  RBDVolumeSource rbd = 6;

  // ISCSI represents an ISCSI Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod. Provisioned by an admin.
  ISCSIVolumeSource iscsi = 7;

  // Cinder represents a cinder volume attached and mounted on kubelets host machine
  // More info: http://releases.k8s.io/release-1.4/examples/mysql-cinder-pd/README.md
  CinderVolumeSource cinder = 8;

  // CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
  CephFSVolumeSource cephfs = 9;

  // FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
  FCVolumeSource fc = 10;

  // Flocker represents a Flocker volume attached to a kubelet's host machine and exposed to the pod for its usage. This depends on the Flocker control service being running
  FlockerVolumeSource flocker = 11;

  // FlexVolume represents a generic volume resource that is
  // provisioned/attached using an exec based plugin. This is an
  // alpha feature and may change in future.
  FlexVolumeSource flexVolume = 12;

  // AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
  AzureFileVolumeSource azureFile = 13;

  // VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
  VsphereVirtualDiskVolumeSource vsphereVolume = 14;

  // Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
  QuobyteVolumeSource quobyte = 15;

  // AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
  AzureDiskVolumeSource azureDisk = 16;

  // EmptyDir represents a temporary directory that shares a pod's lifetime.
  // More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
  // +optional
  EmptyDirVolumeSource emptyDir = 17;

  // GitRepo represents a git repository at a particular revision.
  // +optional
  GitRepoVolumeSource gitRepo = 18;

  // Secret represents a secret that should populate this volume.
  // More info: http://kubernetes.io/docs/user-guide/volumes#secrets
  // +optional
  SecretVolumeSource secret = 19;

  // PersistentVolumeClaimVolumeSource represents a reference to a
  // PersistentVolumeClaim in the same namespace.
  // More info: http://kubernetes.io/docs/user-guide/persistent-volumes#persistentvolumeclaims
  // +optional
  PersistentVolumeClaimVolumeSource persistentVolumeClaim = 20;

  // DownwardAPI represents downward API about the pod that should populate this volume
  // +optional
  DownwardAPIVolumeSource downwardAPI = 21;

  // ConfigMap represents a configMap that should populate this volume
  // +optional
  ConfigMapVolumeSource configMap = 22;

  // PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
  PhotonPersistentDiskVolumeSource photonPersistentDisk = 23;

}

// Represents a Persistent Disk resource in AWS.
//
// An AWS EBS disk must exist before mounting to a container. The disk
// must also be in the same AWS zone as the kubelet. An AWS EBS disk
// can only be mounted as read/write once. AWS EBS volumes support
// ownership management and SELinux relabeling.
message AWSElasticBlockStoreVolumeSource {
  // Unique ID of the persistent disk resource in AWS (Amazon EBS volume).
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#awselasticblockstore
  string volumeID = 1;

  // Filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#awselasticblockstore
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  string fsType = 2;

  // The partition in the volume that you want to mount.
  // If omitted, the default is to mount by volume name.
  // Examples: For volume /dev/sda1, you specify the partition as "1".
  // Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
  int32 partition = 3;

  // Specify "true" to force and set the ReadOnly property in VolumeMounts to "true".
  // If omitted, the default is "false".
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#awselasticblockstore
  bool readOnly = 4;
}

// Represents a host path mapped into a pod.
// Host path volumes do not support ownership management or SELinux relabeling.
message HostPathVolumeSource {
  // Path of the directory on the host.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#hostpath
  string path = 1;
}

// Adapts a Secret into a volume.
//
// The contents of the target Secret's Data field will be presented in a volume
// as files using the keys in the Data field as the file names.
// Secret volumes support ownership management and SELinux relabeling.
message SecretVolumeSource {
  // Name of the secret in the pod's namespace to use.
  // More info: http://kubernetes.io/docs/user-guide/volumes#secrets
  string secretName = 1;

  // If unspecified, each key-value pair in the Data field of the referenced
  // Secret will be projected into the volume as a file whose name is the
  // key and content is the value. If specified, the listed keys will be
  // projected into the specified paths, and unlisted keys will not be
  // present. If a key is specified which is not present in the Secret,
  // the volume setup will error unless it is marked optional. Paths must be
  // relative and may not contain the '..' path or start with '..'.
  repeated KeyToPath items = 2;

  // Optional: mode bits to use on created files by default. Must be a
  // value between 0 and 0777. Defaults to 0644.
  // Directories within the path are not affected by this setting.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  int32 defaultMode = 3;
}

// Maps a string key to a path within a volume.
message KeyToPath {
  // The key to project.
  string key = 1;

  // The relative path of the file to map the key to.
  // May not be an absolute path.
  // May not contain the path element '..'.
  // May not start with the string '..'.
  string path = 2;

  // Optional: mode bits to use on this file, must be a value between 0
  // and 0777. If not specified, the volume defaultMode will be used.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  int32 mode = 3;
}

// Represents an empty directory for a pod.
// Empty directory volumes support ownership management and SELinux relabeling.
message EmptyDirVolumeSource {
  // What type of storage medium should back this directory.
  // The default is "" which means to use the node's default medium.
  // Must be an empty string (default) or Memory.
  // More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
  string medium = 1;
}

// PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace.
// This volume finds the bound PV and mounts that volume for the pod. A
// PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another
// type of volume that is owned by someone else (the system).
message PersistentVolumeClaimVolumeSource {
  // ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
  // More info: http://kubernetes.io/docs/user-guide/persistent-volumes#persistentvolumeclaims
  string claimName = 1;

  // Will force the ReadOnly setting in VolumeMounts.
  // Default false.
  // +optional
  bool readOnly = 2;
}

// DownwardAPIVolumeSource represents a volume containing downward API info.
// Downward API volumes support ownership management and SELinux relabeling.
message DownwardAPIVolumeSource {
  // Items is a list of downward API volume file
  // +optional
  repeated DownwardAPIVolumeFile items = 1;

  // Optional: mode bits to use on created files by default. Must be a
  // value between 0 and 0777. Defaults to 0644.
  // Directories within the path are not affected by this setting.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  int32 defaultMode = 2;
}

// DownwardAPIVolumeFile represents information to create the file containing the pod field
message DownwardAPIVolumeFile {
  // Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
  string path = 1;

  // Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
  // +optional
  ObjectFieldSelector fieldRef = 2;

  // Selects a resource of the container: only resources limits and requests
  // (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
  // +optional
  ResourceFieldSelector resourceFieldRef = 3;

  // Optional: mode bits to use on this file, must be a value between 0
  // and 0777. If not specified, the volume defaultMode will be used.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  int32 mode = 4;
}

message ConfigMapVolumeSource {
  LocalObjectReference localObjectReference = 1;

  // If unspecified, each key-value pair in the Data field of the referenced
  // ConfigMap will be projected into the volume as a file whose name is the
  // key and content is the value. If specified, the listed keys will be
  // projected into the specified paths, and unlisted keys will not be
  // present. If a key is specified which is not present in the ConfigMap,
  // the volume setup will error unless it is marked optional. Paths must be
  // relative and may not contain the '..' path or start with '..'.
  // +optional
  KeyToPath items = 2;

  // Optional: mode bits to use on created files by default. Must be a
  // value between 0 and 0777. Defaults to 0644.
  // Directories within the path are not affected by this setting.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  int32 defaultMode = 3;

  // Specify whether the ConfigMap or it's keys must be defined
  // +optional
  bool optional = 4;
}

// Represents a Photon Controller persistent disk resource.
message PhotonPersistentDiskVolumeSource {
  // ID that identifies Photon Controller persistent disk
  string pdID = 1;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  string fsType = 2;
}

// LocalObjectReference contains enough information to let you locate the
// referenced object inside the same namespace.
message LocalObjectReference {
  // Name of the referent.
  // More info: http://kubernetes.io/docs/user-guide/identifiers#names
  // TODO: Add other useful fields. apiVersion, kind, uid?
  // +optional
  string name = 1;
}

// Represents an NFS mount that lasts the lifetime of a pod.
// NFS volumes do not support ownership management or SELinux relabeling.
message NFSVolumeSource {
  // Server is the hostname or IP address of the NFS server.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#nfs
  string server = 1;

  // Path that is exported by the NFS server.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#nfs
  string path = 2;

  // ReadOnly here will force
  // the NFS export to be mounted with read-only permissions.
  // Defaults to false.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#nfs
  bool readOnly = 3;
}

// Represents a Fibre Channel volume.
// Fibre Channel volumes can only be mounted as read/write once.
// Fibre Channel volumes support ownership management and SELinux relabeling.
message FCVolumeSource {
  // Required: FC target worldwide names (WWNs)
  repeated string targetWWNs = 1;

  // Required: FC target lun number
  int32 lun = 2;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  string fsType = 3;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  bool readOnly = 4;
}

// FlexVolume represents a generic volume resource that is
// provisioned/attached using an exec based plugin. This is an alpha feature and may change in future.
message FlexVolumeSource {
  // Driver is the name of the driver to use for this volume.
  string driver = 1;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
  string fsType = 2;

  // Optional: SecretRef is reference to the secret object containing
  // sensitive information to pass to the plugin scripts. This may be
  // empty if no secret object is specified. If the secret object
  // contains more than one secret, all secrets are passed to the plugin
  // scripts.
  ObjectReference secretRef = 3;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  bool readOnly = 4;

  // Optional: Extra command options if any.
  map<string, string> options = 5;
}

// Represents a Flocker volume mounted by the Flocker agent.
// Flocker volumes do not support ownership management or SELinux relabeling.
message FlockerVolumeSource {
  // Required: the volume name. This is going to be store on metadata -> name on the payload for Flocker
  string datasetName = 1;
}

// Represents a Persistent Disk resource in Google Compute Engine.
//
// A GCE PD must exist before mounting to a container. The disk must
// also be in the same GCE project and zone as the kubelet. A GCE PD
// can only be mounted as read/write once or read-only many times. GCE
// PDs support ownership management and SELinux relabeling.
message GCEPersistentDiskVolumeSource {
  // Unique name of the PD resource in GCE. Used to identify the disk in GCE.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#gcepersistentdisk
  string pdName = 1;

  // Filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#gcepersistentdisk
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  string fsType = 2;

  // The partition in the volume that you want to mount.
  // If omitted, the default is to mount by volume name.
  // Examples: For volume /dev/sda1, you specify the partition as "1".
  // Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#gcepersistentdisk
  int32 partition = 3;

  // ReadOnly here will force the ReadOnly setting in VolumeMounts.
  // Defaults to false.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#gcepersistentdisk
  bool readOnly = 4;
}

// Represents a volume that is populated with the contents of a git repository.
// Git repo volumes do not support ownership management.
// Git repo volumes support SELinux relabeling.
message GitRepoVolumeSource {
  // Repository URL
  string repository = 1;

  // Commit hash for the specified revision.
  string revision = 2;

  // Target directory name.
  // Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
  // git repository.  Otherwise, if specified, the volume will contain the git repository in
  // the subdirectory with the given name.
  string directory = 3;
}

// Represents a Glusterfs mount that lasts the lifetime of a pod.
// Glusterfs volumes do not support ownership management or SELinux relabeling.
message GlusterfsVolumeSource {
  // EndpointsName is the endpoint name that details Glusterfs topology.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/glusterfs/README.md#create-a-pod
  string endpoints = 1;

  // Path is the Glusterfs volume path.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/glusterfs/README.md#create-a-pod
  string path = 2;

  // ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions.
  // Defaults to false.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/glusterfs/README.md#create-a-pod
  bool readOnly = 3;
}

// Represents a Rados Block Device mount that lasts the lifetime of a pod.
// RBD volumes support ownership management and SELinux relabeling.
message RBDVolumeSource {
  // A collection of Ceph monitors.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it
  repeated string monitors = 1;

  // The rados image name.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it
  string image = 2;

  // Filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#rbd
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  string fsType = 3;

  // The rados pool name.
  // Default is rbd.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it.
  string pool = 4;

  // The rados user name.
  // Default is admin.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it
  string user = 5;

  // Keyring is the path to key ring for RBDUser.
  // Default is /etc/ceph/keyring.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it
  string keyring = 6;

  // SecretRef is name of the authentication secret for RBDUser. If provided
  // overrides keyring.
  // Default is nil.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it
  ObjectReference secretRef = 7;

  // ReadOnly here will force the ReadOnly setting in VolumeMounts.
  // Defaults to false.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it
  bool readOnly = 8;
}

// Represents an ISCSI disk.
// ISCSI volumes can only be mounted as read/write once.
// ISCSI volumes support ownership management and SELinux relabeling.
message ISCSIVolumeSource {
  // iSCSI target portal. The portal is either an IP or ip_addr:port if the port
  // is other than default (typically TCP ports 860 and 3260).
  string targetPortal = 1;

  // Target iSCSI Qualified Name.
  string iqn = 2;

  // iSCSI target lun number.
  int32 lun = 3;

  // Optional: Defaults to 'default' (tcp). iSCSI interface name that uses an iSCSI transport.
  string iscsiInterface = 4;

  // Filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#iscsi
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  string fsType = 5;

  // ReadOnly here will force the ReadOnly setting in VolumeMounts.
  // Defaults to false.
  bool readOnly = 6;
}

// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
message AzureFileVolumeSource {
  // the name of secret that contains Azure Storage Account Name and Key
  string secretName = 1;

  // Share Name
  string shareName = 2;

  // Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  bool readOnly = 3;
}

// Represents a vSphere volume resource.
message VsphereVirtualDiskVolumeSource {
  // Path that identifies vSphere volume vmdk
  string volumePath = 1;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  string fsType = 2;
}

// Represents a Quobyte mount that lasts the lifetime of a pod.
// Quobyte volumes do not support ownership management or SELinux relabeling.
message QuobyteVolumeSource {
  // Registry represents a single or multiple Quobyte Registry services
  // specified as a string as host:port pair (multiple entries are separated with commas)
  // which acts as the central registry for volumes
  string registry = 1;

  // Volume is a string that references an already created Quobyte volume by name.
  string volume = 2;

  // ReadOnly here will force the Quobyte volume to be mounted with read-only permissions.
  // Defaults to false.
  bool readOnly = 3;

  // User to map volume access to
  // Defaults to serivceaccount user
  string user = 4;

  // Group to map volume access to
  // Default is no group
  string group = 5;
}

// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
message AzureDiskVolumeSource {
  // The Name of the data disk in the blob storage
  string diskName = 1;

  // The URI the data disk in the blob storage
  string diskURI = 2;

  // Host Caching mode: None, Read Only, Read Write.
  string cachingMode = 3;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  string fsType = 4;

  // Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  bool readOnly = 5;
}

// Represents a cinder volume resource in Openstack.
// A Cinder volume must exist before mounting to a container.
// The volume must also be in the same region as the kubelet.
// Cinder volumes support ownership management and SELinux relabeling.
message CinderVolumeSource {
  // volume id used to identify the volume in cinder
  // More info: http://releases.k8s.io/release-1.4/examples/mysql-cinder-pd/README.md
  string volumeID = 1;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: http://releases.k8s.io/release-1.4/examples/mysql-cinder-pd/README.md
  string fsType = 2;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // More info: http://releases.k8s.io/release-1.4/examples/mysql-cinder-pd/README.md
  bool readOnly = 3;
}

// Represents a Ceph Filesystem mount that lasts the lifetime of a pod
// Cephfs volumes do not support ownership management or SELinux relabeling.
message CephFSVolumeSource {
  // Required: Monitors is a collection of Ceph monitors
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/cephfs/README.md#how-to-use-it
  repeated string monitors = 1;

  // Optional: Used as the mounted root, rather than the full Ceph tree, default is /
  string path = 2;

  // Optional: User is the rados user name, default is admin
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/cephfs/README.md#how-to-use-it
  string user = 3;

  // Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/cephfs/README.md#how-to-use-it
  string secretFile = 4;

  // Optional: SecretRef is reference to the authentication secret for User, default is empty.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/cephfs/README.md#how-to-use-it
  ObjectReference secretRef = 5;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/cephfs/README.md#how-to-use-it
  bool readOnly = 6;
}

message EnvVar {
  // Name of the environment variable. Must be a C_IDENTIFIER.
  string name = 1;

  // Variable references $(VAR_NAME) are expanded
  // using the previous defined environment variables in the container and
  // any service environment variables. If a variable cannot be resolved,
  // the reference in the input string will be unchanged. The $(VAR_NAME)
  // syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped
  // references will never be expanded, regardless of whether the variable
  // exists or not.
  // Defaults to "".
  // +optional
  string value = 2;

  // Source for the environment variable's value. Cannot be used if value is not empty.
  // +optional
  EnvVarSource value_from = 3;
}

// EnvVarSource represents a source for the value of an EnvVar.
message EnvVarSource {
  // Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations,
  // spec.nodeName, spec.serviceAccountName, status.podIP.
  // +optional
  ObjectFieldSelector field_ref = 1;

  // Selects a resource of the container: only resources limits and requests
  // (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
  // +optional
  ResourceFieldSelector resource_field_ref = 2;

  // Selects a key of a ConfigMap.
  // +optional
  ConfigMapKeySelector config_map_key_ref = 3;

  // Selects a key of a secret in the pod's namespace
  // +optional
  SecretKeySelector secret_key_ref = 4;
}

// ObjectFieldSelector selects an APIVersioned field of an object.
message ObjectFieldSelector {
  // Version of the schema the FieldPath is written in terms of, defaults to "v1".
  // +optional
  string api_version = 1;

  // Path of the field to select in the specified API version.
  string field_path = 2;
}

// ResourceFieldSelector represents container resources (cpu, memory) and their output format
message ResourceFieldSelector {
  // Container name: required for volumes, optional for env vars
  // +optional
  string container_name = 1;

  // Required: resource to select
  string resource = 2;

  // Specifies the output format of the exposed resources, defaults to "1"
  // +optional
  string divisor = 3;
}

// Selects a key from a ConfigMap.
message ConfigMapKeySelector {
  // The ConfigMap to select from.
  ObjectReference local_object_reference = 1;

  // The key to select.
  string key = 2;
}

// SecretKeySelector selects a key of a Secret.
message SecretKeySelector {
  // The name of the secret in the pod's namespace to select from.
  ObjectReference local_object_reference = 1;

  // The key of the secret to select from.  Must be a valid secret key.
  string key = 2;
}